# Chapter 4 - Encoding and Evolution
Since the need of *rolling upgrade*, the new and old version of data formats needed to be working together. Thus need compatibility in both directions:
+ Backward compatibility
    + New code can read data that was written by older code.
+ Forward compatibility
    + Older code can read data that was written by newer code.

##### Formats for Encoding Data
Mainly two ways of working with data: (data representation)
+ data is kept in objects, structs, lists, arrays, hash tables, trees, etc. These data structure are optmized for access and manipulated by the CPU (using pointers)
+ Encode data into self-contained sequence of bytes

Thus, we need a translation between the two representation.
+ memory -> byte sequence : *encoding*
+ byte -> memory: *decoding*

##### Language-Specific Format
Built-in support for encoding in-momory objects for different programming languages have lots of deep problem:
+ encoding tied to a particular language and it is difficult reading it in other language.
+ In order to restore the data, the decoding process needs to be instaniate arbitrary class. And it has security risk.
+ Version data is also neglected.
+ Efficiency may be a problem.

##### Standardized encoding
Although it is a standardized data representation, it might have below problems:
+ The ambiguity around the encoding of numbers
+ Will have problem when dealing with large numbers
+ Don't support well [binary strings](https://www.ibm.com/support/knowledgecenter/en/SSAE4W_9.6.0/db2/rbafzbinarystrg.htm) for JSON, XML
+ Application don't use XML/JSON need to optentially hardcode the encoding/decoding logic. Or schema is not included in some standardized encoding type (For example, CSV)

##### Modes of Dataflow
+ Via databases
+ Via service calls
+ Via asynchronous message passing

**Through Databases**
storing something in database: *as sending a message to your future self*
Forward / Backward compatibility required, since:
+ old application may reads the data generated by new code
+ *data outlives code* is also possible

**Through Services: REST and RPC**
The most common arrangement:
+ *clients*
+ *servers*
+ *services* (the API exposed by the server)

One service makes a request to another when it requires some functionality or data from that other service. This way of building applications has traditionally been called a *service-oriented architecture (SOA)*, more recently refined and rebranded as *microservices architecture*.
One key desgin goal of SOA is:
Make the application easier to change and maintain by making services independently deployable and evolvable. 

**Web Services**
Web services have several context:
1. A client application running on a user’s device
    + making requests to a service over HTTP. These requests typically go over the public internet.
2. One service making requests to another service owned by the same organization, often located within the same datacenter, as part of a service-oriented/microservices architecture.
    + (Software that supports this kind of use case is sometimes called middleware.)
3. One service making requests to a service owned by a different organization, usually via the internet. This is used for data exchange between different organizations’ backend systems. 
    + This category includes public APIs provided by online services, such as credit card processing systems, or OAuth for shared access to user data.

About **REST**:
+ Emphasizes simple data formats, using URLs for identifying resources and using HTTP features for cache control, authentication, and content type negotiation. 

About **SOAP**:
+ Enables code generation so that a client can access a remote service using local classes and method calls
+ users of SOAP rely heavily on tool support, code generation, and IDEs

RESTful APIs tend to favor simpler approaches, typically involving less code genera‐ tion and automated tooling. 

**Problems with remote procedure calls(RPCs)**
RPC: 
+ make a request to a remote network service look the same as calling a function or method in your programming language, within the same process (this abstraction is called location transparency).

Problems:
+ A network request is unpredictable
+ Reuqest may returns without a result
+ The application may try to send multiple times of request, unless you have logic for deduplication *(idempotence)*
+ Network request may be much more slower than function call
+ function call can only takes a reference, but the network request need to pass a sequence of encoded bytes
+ Code will end up ugly for integration since the client and the server may use different programming languages and framework

##### Message-Passing Dataflow
*asynchronous message-passing systems*:
goes via an intermediary called a *message broker (also called a message queue or message-oriented middleware)*, which stores the message temporarily.

Used a message broker compared to direct PRC:
+ It can act as a buffer if the recipient is unavailable or overloaded, and thus improve system reliability.
+ It can automatically redeliver messages to a process that has crashed, and thus prevent messages from being lost.
+ It avoids the sender needing to know the IP address and port number of the recipient (which is particularly useful in a cloud deployment where virtual machines often come and go).
+ It allows one message to be sent to several recipients.
+ It logically decouples the sender from the recipient (the sender just publishes messages and doesn’t care who consumes them).

**Message brokers**
Works like:
+ one process sends a message to *queue or topic*
+ the boroker ensures the message is delivered to one or more *customer* of or *subscribers* to that queue or topic

**Distributed actor frameworks**
Integrates a message broker and the *actor programming model* into a single framework.
+ [The actor model](https://www.youtube.com/watch?v=ELwEdb_pD0k) is a programming model for concurrency in a single process. Rather than dealing directly with threads (and the associated problems of race conditions, locking, and deadlock), logic is encapsulated in actors.

